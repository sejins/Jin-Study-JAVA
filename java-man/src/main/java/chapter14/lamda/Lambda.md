# 람다식    

`JDK 1.8`부터 추가된 람다식으로 인해서, JDK 1.5의 제네릭 이후로 자바는 또 엄청난 변화를 맞이했다.  

람다식의 도입으로 인해서 자바는 `객체지향 언어`인 동시에 `함수형 언어`의 성격까지 띄게 된다.  

처음 람다식을 공부하면서, 내가 지금까지 공부하면서 느낀 자바는 정말 철저하게 객체 지향적인 성향을 띄는 언어였는데, 함수형 언어라는 
패러다임을 어떻게 자바에 스며들게 했는지 궁금했다.  

### **람다식이란?**  

간단히 말해서 람다식이란 메서드를 하나의 `식(expression)`으로 표현한 것이다.  

여기서 간단하게 `statement` 와 `expression` 의 차이에 대해서 다시 환기하고 가도록 하자.  

[statement 와 expression 의 차이](https://shoark7.github.io/programming/knowledge/expression-vs-statement)  

대충..  식이란 계산 후 하나의 값(value)으로 환원되는 것을 말한다.  

```java
Arrays.setAll(arr, () -> (int)(Math.random*()*5)+1);
```  
이렇게 메서드를 람다식으로 표현하게 되면 메서드의 이름과 반환값이 없어지게 된다.
그래서 람다식을 `익명함수` 라고도 한다.  

위의 람다식이 메서드로 구현된 것 보다 간결하면서 직관적으로 이해하기가 쉽다는 것에 이견이 없을 것이다.  
라고 책에 설명이 되어있는데,, 물론 적응이 되고 익숙해지면 그럴 것 같다👍  

일반적으로 자바에서 메서드를 생성하기 위해서는 클래스도 생성해야하고, 그리고 그 메서드를 사용하기 위해서는
객체를 생성하고 메서드를 수행해야하는데,  

람다식을 사용하면 이러한 모든 과정 없이 가능하다.  

그리고 위에서 식(expression)이란 계산 후 하나의 값으로 환원되는 것이라고 했는데,  
그렇다. 메서드를 하나의 값으로 간주하게 되면 이를 변수에 저장할 수 있는 것이고, 매개변수로 전달할 수있고,
그리고 반환 값으로도 사용할 수 있게 되는 것이다.  

람다식을 통해서 `메서드`를 하나의 `값`으로 사용할 수 있는 것이다.  

### **람다식 작성하기**  

람다식을 작성하는 방법은 앞의 예제를 통해서 유추해볼 수 있었을 것이다.  

익명함수 답게 먼저 메서드의 이름부터 날린다.  그리고 반환타입도 제거한다.  
그리고 남아있는 매개변수 선언부와 body 부분 사이에 화살표를 추가한다.  

그냥 예를 몇번 만들어보고 이해하자.  

```java
int max(int a, int b){
    return a>b ? a : b ;
        }
```  
이것을 람다식으로 표현하면 다음과 같다. 하나의 식 이라는 것에 집중을 해보자.

```java
(int a, int b) -> {return a>b ? a : b ;}
```  
이는 식이고 `하나의 값`으로 간주할 수 있기 때문에 변수에 저장하거나 매개변수로 넘겨주거나 반환값으로 
리턴할 수 있다.  

그리고 `return` 문은 또 다시 식으로 표현 할 수 있다. return 은 값을 반환하니까 값을 
반대로 식으로 나타낼 수 있는 것이라고 생각하자.  
이는 식이라서 `;` 을 붙히지 않는다는 점을 주의하자.  
```java
(int a, int b) -> a > b ? a : b
```  

또 람다식에 선언된 매개변수의 타입이 추론이 가능한 경우에는 생략이 가능하다.  
대부분의 경우에 생략이 가능한데, 이는 차차 알게 될 것이다.  
```java
(a,b) -> a > b ? a : b
```  
이렇게 표현하니 확실히 메서드를 선언하고 사용하는 것 보다 코드상으로도 간결하다.  

매개변수가 하나뿐인 경우에는 괄호를 생략할 수 있다.  
단, 매개변수의 타입이 있을 경우에는 괄호를 생략할 수 없다.  
```java
a -> a + a // 가능
int a -> a + a // 안됨
```  

마지막으로 중괄호 `{}` 안의 문장이 하나만 존재할 경우에는 중괄호를 생략할 수 있다.  
이 때도 `;` 를 붙히지 않아야 하는 것에 주의하자.  
```java
(String name, int age) -> System.out.println(name + " : " + age)
```  

하지만 중괄호 안의 문장이 return 문일 경우에는 중괄호의 생략이 불가능하다.  
```java
(a,b) -> return a > b ? a : b  // 불가능!
(a,b) -> {return a > b ? a : b ;} // 가능
```  

### **함수형 인터페이스** 

그렇다면 람다식이 값이라고 했고, 람다식의 타입은 어떻게 되는 것일까?  

처음 람다식을 접했을 때, 자바의 객체 지향을 그대로 유지하면서 함수형 패러다임을 적용했던 것을 보고
감탄을  하기도 했었다.  

사실 람다식은 `익명 클래스`의 `구현체(객체)`와 동등하다.  

```java
(int a, int b) -> a > b ? a : b 
```  
```java
new Object(){
    int max(int a, int b){
        return a>b ? a : b ;
        }
}
```  
두 개는 같다고 볼 수있다.  
여기서 메서드의 이름 max는 임의로 붙인 것일 뿐 의미는 없다.  

그렇다면 여기서 람다식의 타입을 Myfunction 타입이 될 것이고, 이는 클래스 또는 인터페이스 일 것이다.  

다음과 같은 인터페이스가 정의되어 있다고 가정해보자.  

```java
Interface Myfunction{
    public abstract int max(int a, int b);
        }
```  
그리고 이 인터페이스를 구현한 익명 클래스의 객체는 이렇게 생성할 수 있을 것이다.  
```java
Myfunction f = new Myfunction(){
        public int max(int a, int b){
            return a > b ? a : b;
            }
    };
int big = f.max(3,5);
```
여기서 Myfunction 인터페이스에 정의된 max 메서드와 람다식의 선언부가 일치하게 된다.  

그래서 익명 객체를 `람다식`으로 대체를 할 수 있다.  
```java
Myfunction f = (a,b) -> a > b ? a : b ; // 익명 객체를 람다식으로 대체.
int big = f.max(3,5); // 익명 객체의 메서드를 호출
```  

이렇게 익명 객체를 람다식으로 다룰 수 있는 이유는 람다식도 실제로는 익명 객체이고, 
Myfunction 인터페이스를 구현한 익명 객체의 메서드 max() 와 람다식이 매개변수 `타입`, `개수`, `반환타입`이
일치하기 때문이다.  

이렇게 람다식을 사용하지만, 기존의 객체 지향적 규칙들을 위배하지도 않고 자연스럽게 녹아든다.  

그렇기 때문에 자바에서 이렇게 인터페이스를 통해 람다식을 다루기로 결정했고 이를 `함수형 인터페이스` 라고 한다.  

```java
@FunctionalInterface
interface Myfunction{
    public abstract int max(int a, int b);
}
```  
람다식과 함수형 인터페이스가 1 대 1 로 매핑 하기 위해서 함수형 인터페이스에는 `오직 하나의 추상메서드`만 
정의 되어 있어야한다.  
하지만 `static 메서드`와 `default 메서드`의 개수에는 제약이 없다.  
그리고 표준 애너테이션의 @FunctionalInterface 을 사용하면 컴파일러가 함수형 인터페이스를 올바르게 
선언했는지 확인해주니까 반드시 쓰도록 하자.  

**함수형 인터페이스 타입의 매개변수와 반환 타입**  

만일 어떤 메서드의 매개변수 타입이 함수형 인터페이스 타입이면, 메서드의 매개변수로 람다식을 참조하는 
참조변수를 넘겨줘야 한다는 말이다. 
```java
...
void aMethod(Myfunction f){
    f.myMethod();
        }
...

aMethod(() -> System.out.println("myMethod"));
```  
이런식으로 직접 람다식을 매개변수로 지정하는 것이 가능하다.  

마찬가지로 어떤 메서드의 반환 타입이 함수형 인터페이스일 경우에 직접 람다식을 리턴할 수 있다.  

이렇게 람다식을 값처럼 사용할 수 있고, 그 타입은 함수형 인터페이스가 되는 것이다.  

**정리하자면** 람다식은 사실 익명 클래스의 구현 객체이다.  그리고 이러한 람다식의 구현 모체가 되는 것이
함수형 인터페이스이다.  
객체 지향 방식을 유지하면서 람다식을 사용하기 위해서 이렇게 함수형 인터페이스를 사용하고, 
사실상 함수형 인터페이스가 람다식의 타입이 된다고 생각할 수 있다. 🙏  

아 확실히 한번 더 보니까 예전 보다는 빠르고 더 정확하게 이해되는 것 같다~ 무야호🙀  

LambdaEx 예제  

